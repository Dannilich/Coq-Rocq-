(** printing  * #*# *)


(* Квадратные скобки в комментариях ниже выделяют участки кода и не
являются частью самого кода. Они нужны при генерировании HTML. *)

(** * Лекция 1. Пропозициональная логика *)

(**
Суждениями (вещами, которые доказываются с помощью построения вывода)
являются секвенции, имеющие вид [Gamma |- A], где [Gamma] — конечная
последовательность формул, [A] — формула. Смысл [Gamma |- A]:
конъюнкция формул в Gamma влечет A. Символ |- называется "штопор"
("turnstile"). В Coq каждая формула из Gamma имеет свою
метку-идентификатор. Секвенция [H1 : A1, H2 : A2 |- B] записывается в
виде

[[
H1 : A1
H2 : A2
============================
B
]]

Система правил вывода похожа на исчисление, называемое "Натуральный
(естественный) вывод". Аксиомами называются секвенции [Gamma |- A],
где [A] входит в [Gamma]. Для каждой логической связки в натуральном
выводе есть правила введения и правила устранения. Первое правило
показывают, как доказать утверждение с этой связкой, а второе — как
использовать такое утверждение. В терминологии автоматизированных
систем доказательства правила вывода называются тактиками.

В натуральном выводе меняются формулы справа от штопора. В Coq
используются также правила, работающие с правилами слева от штопора.

Ниже приведены правила вывода, их названия, обозначения в натуральном
выводе, а также соответствующие тактики Coq.

*** Введение импликации (В->). Тактика [intro]
<<
 Gamma, A |- B
---------------
Gamma |- A -> B
>>

*** Устранение импликации (У->), Модус Поненс
<<
Gamma |- A -> B     Gamma |- A
------------------------------ 
         Gamma |- B
>>

*** Тактика [apply]
В Coq чаще используется следующий аналог (У->)
<<
        Gamma |- A
--------------------------- 
   Gamma, A -> B |- B
>>

*** Введение конъюнкции (В/\). Тактика [split]
<<
Gamma |- A     Gamma |- B
-------------------------
     Gamma |- A /\ B
>>

*** Устранение конъюнкции (У/\)
<<
Gamma |- A /\ B         Gamma |- A /\ B      
---------------         ---------------
  Gamma |- A              Gamma |- B
>>

*** Тактика [destruct]
В Coq используется следующий аналог (У/\)
<<
Gamma, A, B |- C
------------------
Gamma, A /\ B |- C
>>

*** Введение дизъюнкции (В\/). Тактика [left]
<<
  Gamma |- A
---------------
Gamma |- A \/ B
>>

*** Введение дизъюнкции (В\/). Тактика [right]
<<
  Gamma |- B
---------------
Gamma |- A \/ B
>>

*** Устранение дизъюнкции (У\/)
<<
Gamma |- A \/ B   Gamma, A |- C   Gamma, B |- C
------------------------------------------------
                Gamma |- C
>>

*** Тактика [destruct]
В Coq используется следующий аналог (У\/)
<<
Gamma, A |- C    Gamma, B |- C
------------------------------
       Gamma, A \/ B |- C
>>

[~A] (отрицание [A]) является сокращением для [not A], что в свою очередь
по определению является [A -> False], где [False] — тождественно ложная
формула. Это можно увидеть с помощью тактики [unfold not]. Благодаря этому
определению правила для отрицания являются производными от правил для
импликации.

*** Тактика [intro]
<<
Gamma, A |- False
------------------
   Gamma |- ~A
>>

Важно: выводы строятся снизу вверх, начиная с теоремы и заканчивая аксиомами.

Определения, утверждения и доказательства записываются в одном файле.
В CoqIDE файл делится на две области. Первая проверена и принята Coq.
Она имеет зеленый фон. При нажатии на кнопку со стрелкой вниз на панели
инструментов или на клавиши Ctrl+стрелка вниз Coq делает попытку
проверить правильность следуюей команды или тактики. Другие команды
для изменения области находятся в меню Navigation.
*)


Section Lecture01.



(** Переменные [A], [B], [C] объявлены как пропозициональные *)

(** Логические связки располагаются в порядке убывания приоритета
следующим образом: [~], [/\], [\/], [<->], [->] *)




Variables A B C : Prop.

Theorem t1 : A -> A.
Proof.

(** Текущая цель, то есть секвенция, находится в правой верхней
части окна *)

intro H.

(* A -> B -> C -> D = A -> (B -> (C -> D))
Это равносильно A /\ B /\ C -> D *)

(** Возможно также:
- [intro.]



- [intros.]
- [intros H.]
[intros] принимает любое количество посылок, [intro] не более одной. *)

(** В текущей цели формула [A] находится слева и справа от штопора,
поэтому это аксиома. Закончить доказательство можно следующим образом. *)

assumption.

(** Возможны также:
- [trivial.]
- [auto.]
В конце доказательства ставится команда [Qed.]
*)

Qed.

(** У команды [Theorem] есть синонимы: [Lemma], [Remark], [Fact],
[Corollary], [Proposition] *)


Proposition t2 : (A -> B -> C) -> (A -> B) -> (A -> C).
Proof.
intros H1 H2 H3.
apply H1.
assumption.
apply H2.
assumption.
Qed.

Theorem syllogism : (A -> B) -> (B -> C) -> A -> C.
Proof.
intros H1 H2 H3.
apply H2.
apply H1.
trivial.
Qed.

Theorem t3 : A /\ B -> A.
Proof.
intro H.
destruct H as [K L].
assumption.
Qed.

Theorem t4 : (A \/ B -> C) -> (A -> C) /\ (B -> C).
Proof.
intro H.
split.

(** Далее следует доказательства двух подцелей. Начало доказательства
каждой подцели рекомендуется обозначить символом [+]. Это дает два
преимущества. Во-первых, в файле с доказательством в виде
последовательности тактик видно, где заканчивается доказательство
одной подцели и начинается доказательство следующей. Во-вторых, Coq
выдаст сообщение об ошибке, если к следующему [+] предыдущая подцель
не была полностью доказана. Это позволяет легче найти ошибку при
изменении доказательства.

Можно строить вложенную структуру, используя символы [*], [+], [-],
[**], [++] и т.д., например:
[[
* destruct H.
  + split.
    - auto.
    - apply H1. auto.
  + left. trivial.
* assumption.
]]

Вместо использования маркеров [*], [+], [-] и т.д. можно заключить
доказательство каждой подцели в фигурные скобки.
[[
  split. { auto. } { apply H1. auto. }
]]
*)

+ intro H1. apply H. left. trivial.
+ intro H1. apply H. right. trivial.
Qed.

Theorem t5 : (~A \/ ~B) -> ~(A /\ B).
Proof.
  
(** [~A] — это обозначение для [not A], a [not A] определяется как
[A -> False] *)

unfold not.
intros H1 H2.
destruct H2 as [H2 H3].
destruct H1.
{ apply H. trivial. }
{ apply H. trivial. }
Qed.

Fact double_negation : A -> ~~A.
Proof.

unfold not.

(** [~~A] есть [(A -> False) -> False]. Для того, чтобы перенести
[A -> False] в список посылок, не обязательно говорить [unfold not]. *)

intros H1 H2.

(** [H2 : A -> False] *)

apply H2.
assumption.
Qed.

(** [A <-> B] — это обозначение для [iff A B], что в свою очередь значит
по определению [(A -> B) /\ (B -> A)]. В этом можно убедиться с помощью
[unfold iff]. Например, дадим временную недоказуемую цель [A <-> B]. *)

Goal A <-> B.
unfold iff.
split.
Abort.

(** Поэтому доказывать цель вида [A <-> B] нужно тактикой [split],
а использовать посылку вида [H : A <-> B] с помощью
тактики [destruct H as [H1 H2]], где [H1] и [H2] — новые идентификаторы. *)

End Lecture01.

(** * Домашнее задание 1 *)

Section Homework01.

Variables A B C : Prop.

(** Проверьте, работает ли доказательство утверждения double_negation
выше, если вместо [False] поставить произвольную пропозициональную
переменную, например, [B] (следующее утверждение) *)

Corollary double_impl : A -> (A -> B) -> B.
Proof.
unfold not.
intros H1 H2.
apply H2.
assumption.
Qed.

(** Докажите следующие формулы. Замените команду [Admitted] на доказательство,
за которым идет [Qed]. *)

Proposition disj_elim : (A \/ B -> C) <-> (A -> C) /\ (B -> C).
unfold iff.
split.
intros.
split.
intros.
apply H.
-left.
--trivial.
-intros.
--apply H.
---right.
----trivial.
-intros.
--destruct H as [H1 H2].
---destruct H0.
----apply H1.
-----trivial.
----apply H2.
-----trivial.
Qed.

Theorem conj_disj_distr : A /\ (B \/ C) <-> A /\ B \/ A /\ C.
Proof.
unfold iff.
split.
intros.
destruct H as [H1 H2].
destruct H2.
-left  .
--split.
---trivial.
---trivial.
-right.
--split.
---trivial.
---trivial.
-intros.
--destruct H.
---destruct H.
----split.
-----trivial.
-----left.
------trivial.
---destruct H.
----split.
-----trivial.
-----right.
------trivial.
Qed.


Theorem double_neg_intro : A -> ~~A.
Proof.
unfold not.
intros.
apply H0.
assumption.
Qed.

Theorem double_neg_elim : ~~~A -> ~A.
Proof.
unfold not.
intros.
apply H.
intros.
apply H1.
assumption.
Qed.

Theorem deMorgan : ~(A \/ B) <-> ~A /\ ~B.
Proof.
unfold not.
split.
intros.
-split.
--intro.
---apply H.
----left.
-----trivial.
--intro.
---apply H.
----right.
-----trivial.
-intros.
--destruct H.
---destruct H0.
----apply H.
-----trivial.
----apply H1.
-----trivial.
Qed.

End Homework01.
